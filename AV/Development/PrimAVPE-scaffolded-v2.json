{
  "translations" :{
    "en": {
      ".avTitle": "Prim's Algorithm Proficiency Exercise",
      "av_Authors": "Mohammed Fawzi, Kasper Hellström, Artturi Tilanterä",
      ".instructLabel": "Instructions:",
      ".instructions": "Simulate the execution of Prim’s algorithm for the given graph below. Click on an <strong>edge</strong> (u, v) to either enqueue a corresponding element to the priority queue (PQ) or update its priority in the PQ. To determine the correct order to process neighbours of each node, use the given adjacency list representation of the graph. Click <strong>Dequeue</strong> to remove the highest priority element from the PQ, and to add the corresponding edge to the minimum spanning tree (MST). Begin from the node A. The table at the bottom keeps track of the known minimum edge weights connecting each node to the MST and the parent nodes that provide this connection. ",
      "av_ms_mst": "Complete minimum spanning tree",
      "av_ms_select_a": "Start by selecting node A",
      "av_ms_select_node": "Select {node}, since it's closest to the MST.",
      "av_ms_add_edge": "Add edge ({from}, {to}) to the MST.",
      "av_ms_unreachable": "The nearest unvisited node is at infinite distance. The algorithm ends.",
      "av_ms_update_distances": "Update distance to {node}'s neighbors in alphabetic order. For updated nodes, set the closest known node to be {node}",
      "av_ms_visit_neighbor_add": "Update {node}'s neighbors' distances in alphabetic order. Node {neighbor}:<br>The current distance to {neighbor} is infinite. Add {neighbor} to the priority queue and the distance table. Set {neighbor}'s parent to {node}.",
      "av_ms_visit_neighbor_update": "Update {node}'s neighbors' distances in alphabetic order. Node {neighbor}:<br>The distance to {neighbor} from {node} is shorter than the one previously discovered. Update the distance in the priority queue and the table. Set {neighbor}'s parent to {node}.",
      "av_ms_visit_neighbor_no_action": "Update {node}'s neighbors' distances in alphabetic order. Node {neighbor}:<br>The distance to {neighbor} from {node} is longer or equal than the one previously discovered. No update needed.",
      "av_update_not_possible": "It is not possible to update a node that does not exist in the priority queue.",
      "av_dequeue_not_possible": "The priority queue is empty. Nothing to dequeue.",
      "#help": "Help",
      "#about": "About",
      "reset": "New Exercise",
      "#enqueue": "Enqueue",
      "#update": "Update",
      "#dequeue": "Dequeue",
      "priority_queue": "Priority Queue",
      "node": "Node",
      "distance": "Distance",
      "parent": "Parent",
      "edge": "Edge",
      "legend": "Legend",
      "node_explanation": "C has distance 5 from A<br />with parent B",
      "legend_unvisited": "Unvisited",
      "legend_fringe": "Fringe",
      "legend_spanning_tree": "Spanning tree"
    },
    "fi": {
      ".avTitle": "Primin algoritmi",
      "av_Authors": "Mohammed Fawzi, Kasper Hellström, Ari Korhonen",
      ".instructLabel": "Ohjeet:",
      ".instructions": "Simuloi Primin algoritmin suoritusta alla olevalle verkolle. Klikkaa <strong>särmää</strong> (u, v) joko lisätäksesi särmää vastaavan elementin prioriteettijonoon tai päivittääksesi tämän elementin prioriteettia. Määritä oikea järjestys kunkin solmun naapurien läpikäymiseksi käyttämällä annettua verkon seuraajaluetteloesitystä. Klikkaa <strong>Poista</strong> poistaaksesi korkeimman prioriteetin elementin priotiteettijonosta ja lisätäksesi vastaavan särmän pienimpään virityspuuhun. Aloita solmusta A. Alimmaisena oleva taulukko pitää kirjaa kunkin solmun lyhimmästä tiedetystä etäisyydestä pienimmästä virityspuusta sekä vanhemmista, joiden kautta tämä lyhin etäisyys on löydetty.",
      "av_ms_mst": "Verkon pienin virityspuu",
      "av_ms_select_a": "Aloitetaan valitsemalla solmu A.",
      "av_ms_select_node": "Valitaan solmu {node}, koska se sijaitsee lähinnä virityspuuta.",
      "av_ms_add_edge": "Lisätään särmä ({from}, {to}) virityspuuhun.",
      "av_ms_unreachable": "Etäisyys lähimpään vierailemattomaan solmuun on ääretön. Algoritmi päättyy.",
      "av_ms_update_distances": "Päivitetään etäisyyksiä {node}-solmun naapureihin. Päivitetyille solmuille asetetaan {node} lähimmäksi tunnetuksi solmuksi.",
      "av_ms_visit_neighbor_add": "Päivitetään {node}:n naapureiden etäisyydet. Solmu {neighbor}:<br>{neighbor}:n etäisyys on ääretön. Lisätään {neighbor} prioriteettijonoon sekä etäisyys-taulukkoon. Asetetaan {neighbor}:n isäksi {node}.",
      "av_ms_visit_neighbor_update": "Päivitetään {node}:n naapureiden etäisyydet. Solmu {neighbor}:<br>Löydetty {neighbor}:n etäisyys on lyhyempi kuin aikaisemmin löydetty. Päivitetään etäisyys sekä prioriteettijonoon että taulukkoon. Asetetaan {neighbor}:n isäksi {node}.",
      "av_ms_visit_neighbor_no_action": "Päivitetään {node}:n naapureiden etäisyydet. Solmu {neighbor}:<br>Löydetty {neighbor}:n etäisyys on pidempi tai yhtä suuri kuin aikaisemmin löydetty. Päivitystä ei tarvita.",
      "av_update_not_possible": "Ei ole mahdollista päivittää solmua, joka ei ole prioriteettijonossa.",
      "av_dequeue_not_possible": "Prioriteettijono on tyhjä. Ei ole mitään poistettavaa.",
      "#help": "Ohje",
      "#about": "Lisätietoa",
      "reset": "Uusi tehtävä",
      "#enqueue": "Lisää",
      "#update": "Päivitä",
      "#dequeue": "Poista",
      "priority_queue": "Prioriteettijono",
      "node": "Solmu",
      "distance": "Etäisyys",
      "parent": "Vanhempi",
      "edge": "Särmä",
      "legend": "Selite",
      "node_explanation": "C:n etäisyys A:sta on 5<br />vanhemman B kautta",
      "legend_unvisited": "Tuntematon",
      "legend_fringe": "Reunus",
      "legend_spanning_tree": "Virityspuu"
    }
  },
  "params": {
    "JXOP-feedback": "continuous",
    "JXOP-fixmode": "fix"
  }
}
