<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Test Suite</title>
<link rel="stylesheet" href="https://code.jquery.com/qunit/qunit-2.19.4.css">
</head>
<body>
  <div id="qunit"></div>
  <div id="qunit-fixture"></div>
  <script src="https://code.jquery.com/qunit/qunit-2.19.4.js"></script>
  <script src="PqOperationSequence.js"></script>
  <script>
  
    QUnit.module('PqOperation', function() {
      QUnit.test('vertex letter sorting', function(assert) {
        let op = new PqOperation('enq', 'AB');
        let op2 = new PqOperation('enq', 'BA');
        assert.equal(op.edge, 'AB');
        assert.equal(op2.edge, 'AB');
      })

      QUnit.test('equality', function(assert) {
        let op = new PqOperation('enq', 'AB');
        let op2 = new PqOperation('enq', 'AB');
        let op3 = new PqOperation('deq', 'AB');
        let op4 = new PqOperation('enq', 'AE');

        // Equality is symmetric
        assert.true(op.equals(op2));
        assert.true(op2.equals(op));

        // Different operation, same edge
        assert.false(op.equals(op3));

        // Same operation, different edge
        assert.false(op.equals(op4));
      })

      QUnit.test('toString', function(assert) {
        let op = new PqOperation('enq', 'AB');
        assert.equal(op.toString(), 'enqAB');

        let op2 = new PqOperation('deq', 'AC');
        assert.equal(op2.toString(), 'deqAC');

        // Test a string representation of a sequence of operations.
        // Use JSON.stringify to compare lists of strings.
        let arr = [op, op2].map((x) => x.toString(x));
        assert.equal(
          JSON.stringify(arr),
          JSON.stringify(['enqAB', 'deqAC']));

      })      

    })

    QUnit.module('OperableSet', function() {

      QUnit.test('size', function(assert) {
        let s = new OperableSet();
        assert.equal(s.size(), 0)

        s.add('a');
        assert.equal(s.size(), 1);

        s.add('b');
        assert.equal(s.size(), 2);

        // Adding an element twice has no effect
        s.add('a');
        assert.equal(s.size(), 2);
      })

      QUnit.test('toString', function(assert) {
        let s = new OperableSet();
        s.add('a');
        s.add('b');
        assert.equal(s.toString(), '["a","b"]');
      })

      QUnit.test('union', function(assert) {
        let s1 = new OperableSet();
        s1.add('a');
        s1.add('b');
        assert.equal(s1.toString(), '["a","b"]');

        let s2 = new OperableSet();
        s2.add('b');
        s2.add('c');
        assert.equal(s2.toString(), '["b","c"]');

        let s3 = s1.union(s2);
        // Intersection does not change the original sets
        assert.equal(s1.toString(), '["a","b"]');
        assert.equal(s2.toString(), '["b","c"]');
        // The result of the union is correct
        assert.equal(s3.toString(), '["a","b","c"]');
      })

      QUnit.test('intersection', function(assert) {
        let s1 = new OperableSet();
        s1.add('a');
        s1.add('b');
        assert.equal(s1.toString(), '["a","b"]');

        let s2 = new OperableSet();
        s2.add('b');
        s2.add('c');
        assert.equal(s2.toString(), '["b","c"]');

        let s3 = s1.intersection(s2);
        // Intersection does not change the original sets
        assert.equal(s1.toString(), '["a","b"]');
        assert.equal(s2.toString(), '["b","c"]');
        // The result of the intersection is correct
        assert.equal(s3.toString(), '["b"]');
      })

    })      
  </script>
</body>
</html>